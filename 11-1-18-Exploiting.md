# Introduction to Exploiting

## What is the Stack?

- Like a stack of plates. First in, First out. The most recently added element will be the first to be "popped"
- There is a pointer (a variable that holds an address) that keeps track of the most recent "pushed" element
- When you enter a function, a base pointer is added to the stack, which keep track of the function you are currently in.
- A new function will allocate space on the stack that can be used for the function. 

#### Example Code:
```
void func() {
  int number = 20;
  String str = "Hello";
  arr = [2, 3, 4, 5, 6];
}
```

#### Visual Representation of the Stack of above code
```
----------------------
|   Stack pointer    |  
----------------------
|         6          | 
----------------------
|         5          |
----------------------
|         4          |
----------------------
|         3          |
----------------------
|         2          |
----------------------
|   Address of str   |
----------------------
|        20          |
----------------------
|   Base Pointer     |
----------------------
|   Return Pointer   |
----------------------
```
Integers are 4 bytes
Characters are 1 byte
** I'm in **

## Getting Started

### Disclaimer: This is old school exploiting. It will not work with modern technology. This is just to get your foot in the door. So don't try anything stupid


- protostar login: user
- Password: user

```
bash
cd /opt/protostar/bin/

```

## Stack 0

https://web.archive.org/web/20170930034226/https://exploit-exercises.com/protostar/stack0/

*modified* is the variable that we want to change. The reason why this works is because they are using the keyword *volitile* and the *command* gets is used.
If you use the command ```man gets``, you will find that it will say NEVER USE THIS FUNCTION.

Run the program, gave your input and then press enter:
```
./stack0
```

We want to overflow the buffer by 65 bytes. So inputting more than 65 characters will "change" the modified variable, since you have overwritten it.
This is because the "A"s overflowed downwards.

Looking at the stack with gdb
```gdb stack0```, ```set disassembly-flavor intel``` 



## Stack 1

https://web.archive.org/web/20170419031559/https://exploit-exercises.com/protostar/stack1/

```strcpy()``` is less bad then gets(), but is still a big bad
This command does not check for the amount of space when copying the string. So you should be checking yourself when using this command, but stack1 does not.'

Stack 1 copys argv[1] into *buffer*

This exercise whats you to modify *modified* and wants it value of *modified* to be *0x61626364* which is *dcba*

Solution: Type any character 64 times, and then type in *dcba*

#### Try doing stack 2 and stack 3 for practice

## Stack 4

https://web.archive.org/web/20170417130121/https://exploit-exercises.com/protostar/stack4/

Uses gets again, which is bad.
We are trying to call the function ```win()```
In gdb, you can get the address of a function. 
We found that the address in the stack is 0x0804892a
We need to put in the characters 08, 04, 89, 2a
```man ascii`` to view the ascii table
```echo -e "\x20"``` puts in a space

32 bit systems means the registers address are 32 bit size. (4 bytes)
64 bits means that the address sizes are 64 bits. (8 bytes)

How does this work? Well we change the return pointer address to the address of win().

The buffer takes up 64 bytes in stack, the base pointer takes up 4 bytes, and the return pointer takes up 4 bytes. So we need to fill buffer and base pointer to charactesr and then set return pointer to the values we want.
 
```python -c 'print("A"*68 + "\x08\x04\x83\xfa")' | ./stack4```


Jk, memory is stored backwards, so we need to go backwards


```python -c 'print("A"*68 + "\xfa\x83\x04\x08")' | ./stack4```

*If we have padding, use the value 76 instead of 68.*



